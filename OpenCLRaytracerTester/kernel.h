#pragma once
/* 
 * OpenCL Raytracer
 * Copyright (C) 2011-2012 Cyrille Favreau <cyrille_favreau@hotmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */

/*
 * Author: Cyrille Favreau <cyrille_favreau@hotmail.com>
 *
 */

#include <iostream>

const std::string kernel = 
"// Rays\n"
"#define gNbIterations  5\n"
"\n"
"// Textures\n"
"#define gTextureWidth  256\n"
"#define gTextureHeight 256\n"
"#define gTextureDepth  3\n"
"\n"
"#define gVideoColor  4\n"
"#define gVideoWidth  640\n"
"#define gVideoHeight 480\n"
"\n"
"#define gDepthColor       2\n"
"#define gDepthWidth       320\n"
"#define gDepthHeight      240\n"
"#define gTransparentColor 2.9f     // white is the transparent color!\n"
"\n"
"#define gMaxViewDistance 5000.f\n"
"#define gTextureOffset   0.f\n"
"\n"
"#define gDepthOfFieldComplexity 1\n"
"#define gNbMaxShadowCollisions 3\n"
"\n"
"#define NO_TEXTURE -1\n"
"\n"
"// Enums\n"
"enum PrimitiveType \n"
"{\n"
"   ptSphere     = 0,\n"
"   ptTriangle   = 1,\n"
"   ptCheckboard = 2,\n"
"   ptCamera     = 3,\n"
"   ptLeftWall   = 4,\n"
"   ptRightWall  = 5,\n"
"   ptFrontWall  = 6,\n"
"   ptBackWall   = 7,\n"
"   ptTopWall    = 8,\n"
"   ptBottomWall = 9,\n"
"   ptCylinder   = 10\n"
"};\n"
"\n"
"typedef struct\n"
"{\n"
"   float4 color;\n"
"   float  refraction;\n"
"   int    textured;\n"
"   int    transparent;\n"
"   int    textureId;\n"
"   float4 specular;    // x: value, y: power, w: coef\n"
"\n"
"} Material;\n"
"\n"
"typedef struct {\n"
"   float4 center;\n"
"   float4 rotation;\n"
"   float4 size;\n"
"   int    type;\n"
"   int    materialId;\n"
"   float  materialRatioX;\n"
"   float  materialRatioY;\n"
"} Primitive;\n"
"\n"
"typedef struct {\n"
"   float4 center;\n"
"   float4 color;\n"
"} Lamp;\n"
"\n"
"void makeDelphiColor( \n"
"   float4         color, \n"
"   __global char* bitmap, \n"
"   int            index)\n"
"{\n"
"   int mdc_index = index*3;\n"
"   color.x = (color.x>1.f) ? 1.f : color.x;\n"
"   color.y = (color.y>1.f) ? 1.f : color.y;\n"
"   color.z = (color.z>1.f) ? 1.f : color.z;\n"
"   bitmap[mdc_index  ] = (char)(color.z*255.f);\n"
"   bitmap[mdc_index+1] = (char)(color.y*255.f);\n"
"   bitmap[mdc_index+2] = (char)(color.x*255.f);\n"
"}\n"
"\n"
"void makeOpenGLColor(\n"
"   float4         color,\n"
"   __global char* bitmap,\n"
"   int            index)\n"
"{\n"
"   int mdc_index = index*4;\n"
"   color.x = (color.x>1.f) ? 1.f : color.x;\n"
"   color.y = (color.y>1.f) ? 1.f : color.y;\n"
"   color.z = (color.z>1.f) ? 1.f : color.z;\n"
"   color.w = (color.w>1.f) ? 1.f : color.w;\n"
"   bitmap[mdc_index  ] = (char)(color.x*255.f);\n"
"   bitmap[mdc_index+1] = (char)(color.y*255.f);\n"
"   bitmap[mdc_index+2] = (char)(color.z*255.f);\n"
"   bitmap[mdc_index+3] = (char)(color.w*255.f);\n"
"}\n"
"\n"
"#define vectorLength( vector ) \\\n"
"   (sqrt( (vector).x*(vector).x + (vector).y*(vector).y + (vector).z*(vector).z ))\n"
"\n"
"#define normalizeVector( v ) \\\n"
"{ \\\n"
"   float l = vectorLength( v ); \\\n"
"   if( l != 0.f ) { \\\n"
"   v.x = v.x / l; \\\n"
"   v.y = v.y / l; \\\n"
"   v.z = v.z / l; \\\n"
"   } \\\n"
"}\n"
"\n"
"#define dotProduct( v1, v2 )\\\n"
"( v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)\n"
"\n"
"void vectorReflection( float4* reflected, float4 incident, float4 normal )\n"
"{\n"
"   float d = 2.f*dotProduct( incident, normal );\n"
"   *reflected = incident-d*normal;\n"
"}\n"
"\n"
"void vectorRefraction( float4* refracted, float4 incident, float n1, float4 normal, float n2 )\n"
"{\n"
"   (*refracted) = incident;\n"
"   if( n1 != n2 ) \n"
"   {\n"
"      float r = n1/n2;\n"
"      float cosI = dotProduct( incident, normal );\n"
"      float cosT2 = 1.0f - r*r*(1.0f - cosI*cosI);\n"
"      if( cosT2 > 0.01f ) \n"
"      {\n"
"         (*refracted).x = r*incident.x + ((r*cosI-sqrt(fabs(cosT2)))*normal.x);\n"
"         (*refracted).y = r*incident.y + ((r*cosI-sqrt(fabs(cosT2)))*normal.y);\n"
"         (*refracted).z = r*incident.z + ((r*cosI-sqrt(fabs(cosT2)))*normal.z);\n"
"      }\n"
"   }\n"
"}\n"
"\n"
"void vectorRotation( float4* v, float4 center, float4 angles )\n"
"{\n"
"   float4 result = (*v);\n"
"   if( angles.x != 0.f ) \n"
"   {\n"
"      // X Axis\n"
"      result.y = (*v).y*cos(angles.x) - (*v).z*sin(angles.x);\n"
"      result.z = (*v).y*sin(angles.x) + (*v).z*cos(angles.x);\n"
"      (*v) = result;\n"
"   }\n"
"\n"
"   if( angles.y != 0.f ) \n"
"   {\n"
"      result = (*v);\n"
"      // Y axis\n"
"      result.z = (*v).z*cos(angles.y) - (*v).x*sin(angles.y);\n"
"      result.x = (*v).z*sin(angles.y) + (*v).x*cos(angles.y);\n"
"      (*v) = result;\n"
"   }\n"
"}\n"
"\n"
"float4 normalToSurface( \n"
"   Primitive          primitive, \n"
"   float4             intersection, \n"
"   __global char*     depth,\n"
"   __global Material* materials,\n"
"   float              timer )\n"
"{\n"
"   float4 normal;\n"
"   switch( primitive.type ) \n"
"   {\n"
"   case ptSphere:\n"
"      {\n"
"         if( materials[primitive.materialId].textured ) {\n"
"            float4 newCenter;\n"
"            newCenter.x = primitive.center.x + 5.f*cos(timer*0.58f+intersection.x);\n"
"            newCenter.y = primitive.center.y + 5.f*sin(timer*0.85f+intersection.y);\n"
"            newCenter.z = primitive.center.z + 5.f*sin(cos(timer*1.24f+intersection.z));\n"
"            normal = intersection - newCenter;\n"
"            normal *= intersection.w; // -1.f if needs to be inverted\n"
"         }\n"
"         else \n"
"         {\n"
"            normal = intersection - primitive.center;\n"
"            normal *= intersection.w; // -1.f if needs to be inverted\n"
"         }\n"
"         break;\n"
"      }\n"
"   case ptCylinder:\n"
"      {\n"
"         if( materials[primitive.materialId].textured ) \n"
"         {\n"
"            float4 newCenter;\n"
"            newCenter.x = primitive.center.x + 5.f*cos(timer*0.58f+intersection.x);\n"
"            newCenter.y = primitive.center.y + 5.f*sin(timer*0.85f+intersection.y) +intersection.y;\n"
"            newCenter.z = primitive.center.z + 5.f*sin(cos(timer*1.24f+intersection.z));\n"
"            normal = intersection - newCenter;\n"
"         }\n"
"         else \n"
"         {\n"
"            if( fabs(intersection.y - primitive.center.y - primitive.size.y) <= 1.f )\n"
"            {\n"
"               normal.x = 0.f;\n"
"               normal.y = 1.f;\n"
"               normal.z = 0.f;\n"
"            }\n"
"            else if( fabs(intersection.y - primitive.center.y + primitive.size.y) <= 1.f )\n"
"            {\n"
"               normal.x = 0.f;\n"
"               normal.y =-1.f;\n"
"               normal.z = 0.f;\n"
"            }\n"
"            else \n"
"            {\n"
"               normal = intersection - primitive.center;\n"
"               normal.y = 0.f;\n"
"            }\n"
"         }\n"
"         break;\n"
"      }\n"
"   case ptTriangle: \n"
"   case ptCamera:\n"
"      {\n"
"         normal.x =  0.f;\n"
"         normal.y =  0.f;\n"
"         normal.z = -1.f;\n"
"      }\n"
"      break;\n"
"   case ptCheckboard:\n"
"      normal.x =  0.f;\n"
"      normal.y =  1.f;\n"
"      normal.z =  0.f;\n"
"      break;\n"
"   case ptLeftWall:\n"
"      normal.x =  1.f;\n"
"      normal.y =  0.f;\n"
"      normal.z =  0.f;\n"
"      break;\n"
"   case ptRightWall:\n"
"      normal.x = -1.f;\n"
"      normal.y =  0.f;\n"
"      normal.z =  0.f;\n"
"      break;\n"
"   case ptFrontWall:\n"
"      normal.x =  0.f;\n"
"      normal.y =  0.f;\n"
"      normal.z = -1.f;\n"
"      break;\n"
"   case ptBackWall:\n"
"      normal.x =  0.f;\n"
"      normal.y =  0.f;\n"
"      normal.z =  1.f;\n"
"      break;\n"
"   case ptTopWall:\n"
"      normal.x =  0.f;\n"
"      normal.y =  1.f;\n"
"      normal.z =  0.f;\n"
"      break;\n"
"   case ptBottomWall:\n"
"      normal.x =  0.f;\n"
"      normal.y = -1.f;\n"
"      normal.z =  0.f;\n"
"      break;\n"
"   }\n"
"   //vectorRotation( &normal, primitive.center, -primitive.rotation );\n"
"   return normal;\n"
"}\n"
"\n"
"float4 sphereMapping( \n"
"   Primitive          primitive, \n"
"   float4             intersection, \n"
"   __global Material* materials, \n"
"   __global char*     textures )\n"
"{\n"
"   float4 result = materials[primitive.materialId].color;\n"
"   int x = gTextureOffset+(intersection.x-primitive.center.x+primitive.size.x)*primitive.materialRatioX;\n"
"   int y = gTextureOffset+(intersection.y-primitive.center.y+primitive.size.y)*primitive.materialRatioY;\n"
"\n"
"   x = x % gTextureWidth;\n"
"   y = y % gTextureHeight;\n"
"\n"
"   if( x>=0 && x<gTextureWidth&& y>=0 && y<gTextureHeight )\n"
"   {\n"
"      int index = (materials[primitive.materialId].textureId*gTextureWidth*gTextureHeight + y*gTextureWidth+x)*gTextureDepth;\n"
"      unsigned char r = textures[index  ];\n"
"      unsigned char g = textures[index+1];\n"
"      unsigned char b = textures[index+2];\n"
"      result.x = r/256.f;\n"
"      result.y = g/256.f;\n"
"      result.z = b/256.f;\n"
"   }\n"
"   return result; \n"
"}\n"
"\n"
"float4 cubeMapping( \n"
"   Primitive          primitive, \n"
"   float4             intersection, \n"
"   __global Material* materials, \n"
"   __global char*     textures)\n"
"{\n"
"   float4 result = materials[primitive.materialId].color;\n"
"   int x,y;\n"
"   switch( primitive.type ) \n"
"   {\n"
"   case ptCheckboard:\n"
"   case ptTopWall:\n"
"   case ptBottomWall:\n"
"   case ptFrontWall:\n"
"   case ptBackWall:\n"
"      {\n"
"         x = gTextureOffset+(intersection.x-primitive.center.x+primitive.size.x)*primitive.materialRatioX;\n"
"         break;\n"
"      }\n"
"   case ptLeftWall:\n"
"   case ptRightWall:\n"
"      {\n"
"         x = gTextureOffset+(intersection.z-primitive.center.z+primitive.size.x)*primitive.materialRatioX;\n"
"         break;\n"
"      }\n"
"   }\n"
"   x = x % gTextureWidth;\n"
"\n"
"   switch( primitive.type ) \n"
"   {\n"
"   case ptCheckboard:\n"
"   case ptTopWall:\n"
"   case ptBottomWall:\n"
"      {\n"
"         y = gTextureOffset+(intersection.z-primitive.center.z+primitive.size.y)*primitive.materialRatioY;\n"
"         break;\n"
"      }\n"
"   default:\n"
"      {\n"
"         y = gTextureOffset+(intersection.y-primitive.center.y+primitive.size.y)*primitive.materialRatioY;\n"
"         break;\n"
"      }\n"
"   }\n"
"   y = y % gTextureHeight;\n"
"\n"
"   if( x>=0 && x<gTextureWidth&& y>=0 && y<gTextureHeight ) {\n"
"      int index = (materials[primitive.materialId].textureId*gTextureWidth*gTextureHeight + y*gTextureWidth+x)*gTextureDepth;\n"
"      unsigned char r = textures[index+0];\n"
"      unsigned char g = textures[index+1];\n"
"      unsigned char b = textures[index+2];\n"
"      result.x = r/256.f;\n"
"      result.y = g/256.f;\n"
"      result.z = b/256.f;\n"
"   }\n"
"   return result;\n"
"}\n"
"\n"
"float4 objectColorAtIntersection( \n"
"   Primitive          primitive, \n"
"   float4             intersection,\n"
"   __global char*     video,\n"
"   __global char*     depth,\n"
"   __global Material* materials,\n"
"   __global char*     textures,\n"
"   float              timer, \n"
"   bool               back )\n"
"{\n"
"   float4 colorAtIntersection = materials[primitive.materialId].color;\n"
"   switch( primitive.type ) \n"
"   {\n"
"   case ptSphere:\n"
"   case ptCylinder:\n"
"      {\n"
"         if( materials[primitive.materialId].textureId != NO_TEXTURE ) {\n"
"            colorAtIntersection = sphereMapping( primitive, intersection, materials, textures );\n"
"         }\n"
"         else {\n"
"            colorAtIntersection = materials[primitive.materialId].color; \n"
"         }\n"
"         break;\n"
"      }\n"
"   case ptTriangle:\n"
"   case ptCheckboard :\n"
"      {\n"
"         if( materials[primitive.materialId].textureId != NO_TEXTURE ) {\n"
"            colorAtIntersection = cubeMapping( primitive, intersection, materials, textures );\n"
"         }\n"
"         else {\n"
"            int x = gMaxViewDistance + (intersection.x - primitive.center.x)/50.f;\n"
"            int z = gMaxViewDistance + (intersection.z - primitive.center.z)/50.f;\n"
"            if(x%2==0) {\n"
"               if (z%2==0) {\n"
"                  colorAtIntersection.x = 1.0f;\n"
"                  colorAtIntersection.y = 1.0f;\n"
"                  colorAtIntersection.z = 1.0f;\n"
"               }\n"
"            }\n"
"            else {\n"
"               if (z%2!=0) {\n"
"                  colorAtIntersection.x = 1.0f;\n"
"                  colorAtIntersection.y = 1.0f;\n"
"                  colorAtIntersection.z = 1.0f;\n"
"               }\n"
"            }\n"
"         }\n"
"         break;\n"
"      }\n"
"   case ptFrontWall:\n"
"   case ptBackWall:\n"
"   case ptLeftWall:\n"
"   case ptRightWall:\n"
"   case ptTopWall:\n"
"   case ptBottomWall:\n"
"      {\n"
"         if( materials[primitive.materialId].textureId != NO_TEXTURE ) \n"
"         {\n"
"            colorAtIntersection = cubeMapping( primitive, intersection, materials, textures );\n"
"         }\n"
"         break;\n"
"      }\n"
"   case ptCamera:\n"
"      {\n"
"         colorAtIntersection = materials[primitive.materialId].color;\n"
"         int x = (primitive.center.x + intersection.x)+gVideoWidth/2;\n"
"         int y = gVideoHeight/2 - (intersection.y - primitive.center.y);\n"
"         if( x>=0 && x<gVideoWidth && y>=0 && y<gVideoHeight ) \n"
"         {\n"
"            int index = (y*gVideoWidth+x)*4;\n"
"            unsigned char r = video[index+2];\n"
"            unsigned char g = video[index+1];\n"
"            unsigned char b = video[index+0];\n"
"            colorAtIntersection.x = r/256.f;\n"
"            colorAtIntersection.y = g/256.f;\n"
"            colorAtIntersection.z = b/256.f;\n"
"         }\n"
"         break;\n"
"      }\n"
"   }\n"
"   return colorAtIntersection;\n"
"}\n"
"\n"
"bool lampIntersection( \n"
"   Lamp    lamp, \n"
"   float4  origin, \n"
"   float4  ray, \n"
"   float4  O_C,\n"
"   float4* intersection)\n"
"{\n"
"   bool si_b1 = false; \n"
"   float si_A = 2.f*(ray.x*ray.x + ray.y*ray.y + ray.z*ray.z);\n"
"   if ( si_A!=0.f ) {\n"
"      float si_B = 2.f*(O_C.x*ray.x + O_C.y*ray.y + O_C.z*ray.z);\n"
"      float si_C = O_C.x*O_C.x+O_C.y*O_C.y+O_C.z*O_C.z-lamp.center.w*lamp.center.w;\n"
"      float si_radius = si_B*si_B-2.f*si_A*si_C;\n"
"      float si_t1 = (-si_B-sqrt(si_radius))/si_A;\n"
"      if( si_t1>0.f ) {\n"
"         *intersection = origin+si_t1*ray;\n"
"         si_b1 = true;\n"
"      }\n"
"   } \n"
"   return si_b1;\n"
"}\n"
"\n"
"bool sphereIntersection( \n"
"   Primitive          sphere, \n"
"   float4             origin, \n"
"   float4             ray, \n"
"   float              timer,\n"
"   float4*            intersection,\n"
"   bool               computingShadows,\n"
"   float*             shadowIntensity,\n"
"   __global char*     video,\n"
"   __global char*     depth,\n"
"   __global Material* materials,\n"
"   __global char*     textures\n"
"   ) \n"
"{\n"
"   // solve the equation sphere-ray to find the intersections\n"
"   bool result = false;\n"
"   float4 O_C = origin - sphere.center;\n"
"   \n"
"   float a = 2.f*dotProduct(ray,ray);\n"
"   a = ( a==0.f ) ? 0.0001f : a;\n"
"   float b = 2.f*dotProduct(O_C,ray);\n"
"   float c = dotProduct(O_C,O_C) - (sphere.center.w*sphere.center.w);\n"
"   float r = sqrt(b*b-2.f*a*c);\n"
"\n"
"   if ( r >= 0.f ) \n"
"   {\n"
"      float t1 = (-b-r)/a;\n"
"      float t2 = (-b+r)/a;\n"
"      float ta = (t1<t2) ? t1 : t2;\n"
"      \n"
"      if( ta > 0.001f ) \n"
"      {\n"
"         // First intersection\n"
"         *intersection = origin+ta*ray;\n"
"         (*intersection).w = 1.f;\n"
"         result = true ;\n"
"         //result = (/*fabs*/((*intersection).z - sphere.center.z ) >= sphere.center.w/2.f ) ;\n"
"\n"
"         if( result && materials[sphere.materialId].transparent == 1 ) \n"
"         {\n"
"            float4 color = objectColorAtIntersection( sphere, *intersection, video, depth, materials, textures, timer, false );\n"
"            result = ((color.x+color.y+color.z) <= gTransparentColor ); \n"
"         }\n"
"      }\n"
"      \n"
"      if( !result )\n"
"      {\n"
"         float tb = (t2<t1) ? t1 : t2;\n"
"         if( tb > 0.001f ) \n"
"         {\n"
"            // Second intersection\n"
"            *intersection = origin+tb*ray;\n"
"            (*intersection).w = 1.f;\n"
"            result = true ;\n"
"            //result = (/*fabs*/((*intersection).z - sphere.center.z ) >= sphere.center.w/2.f ) ;\n"
"\n"
"            if( result && materials[sphere.materialId].transparent == 1 ) \n"
"            {\n"
"               float4 color = objectColorAtIntersection( sphere, *intersection, video, depth, materials, textures, timer, false );\n"
"               result = ((color.x+color.y+color.z) <= gTransparentColor );\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"\n"
"   if( result && computingShadows ) \n"
"   {\n"
"      float4 normal = normalToSurface( sphere, *intersection, depth, materials, timer ); // Normal is computed twice!!!\n"
"      normalizeVector(normal);\n"
"      normalizeVector(ray );\n"
"      *shadowIntensity = 1.5f*fabs(dotProduct(-ray ,normal));\n"
"      *shadowIntensity = (*shadowIntensity>1.f) ? 1.f : *shadowIntensity;\n"
"   } \n"
"   return result;\n"
"}\n"
"\n"
"bool cylinderIntersection( \n"
"   Primitive          cylinder, \n"
"   float4             origin, \n"
"   float4             ray, \n"
"   float              timer,\n"
"   float4*            intersection,\n"
"   bool               computingShadows,\n"
"   float*             shadowIntensity,\n"
"   __global char*     video,\n"
"   __global char*     depth,\n"
"   __global Material* materials,\n"
"   __global char*     textures\n"
"   ) \n"
"{\n"
"   // solve the equation sphere-ray to find the intersections\n"
"   bool result = false;\n"
"\n"
"   float4 O_C = origin - cylinder.center;\n"
"\n"
"   float a = 2.f * ( ray.x*ray.x + ray.z*ray.z );\n"
"\n"
"   a = ( a==0.f ) ? 0.0001f : a;\n"
"   \n"
"   float b = 2.f*((origin.x-cylinder.center.x)*ray.x + (origin.z-cylinder.center.z)*ray.z);\n"
"\n"
"   float c = \n"
"      O_C.x*O_C.x + \n"
"      O_C.z*O_C.z - \n"
"      cylinder.center.w*cylinder.center.w;\n"
"\n"
"   float r = sqrt(b*b-2.f*a*c);\n"
"\n"
"   // Cylinder\n"
"   if ( r >= 0.f ) \n"
"   {\n"
"      float t1 = (-b-r)/a;\n"
"      float t2 = (-b+r)/a;\n"
"      float ta = (t1<t2) ? t1 : t2;\n"
"      float tb = (t2<t1) ? t1 : t2;\n"
"      if( ta >  0.001f ) \n"
"      {\n"
"         *intersection = origin+ta*ray;\n"
"         result = ( fabs((*intersection).y - cylinder.center.y) < cylinder.size.y );\n"
"         if( result && materials[cylinder.materialId].transparent == 1 ) \n"
"         {\n"
"            float4 color = objectColorAtIntersection( cylinder, *intersection, video, depth, materials, textures, timer, false );\n"
"            result = \n"
"               ( fabs((*intersection).y - cylinder.center.y) < cylinder.size.y ) &&\n"
"               ( (color.x+color.y+color.z) <= gTransparentColor ); \n"
"         }\n"
"      }\n"
"\n"
"      if( !result && tb > 0.001f ) \n"
"      {\n"
"         *intersection = origin+tb*ray;\n"
"         result = ( fabs((*intersection).y - cylinder.center.y) < cylinder.size.y );\n"
"         if( result && materials[cylinder.materialId].transparent == 1 ) \n"
"         {\n"
"            float4 color = objectColorAtIntersection( cylinder, *intersection, video, depth, materials, textures, timer, false );\n"
"            result = \n"
"               ( fabs((*intersection).y - cylinder.center.y) < cylinder.size.y ) &&\n"
"               ( (color.x+color.y+color.z) <= gTransparentColor ); \n"
"         }\n"
"      }\n"
"   }\n"
"\n"
"   if( result && computingShadows ) \n"
"   {\n"
"      float4 normal = normalToSurface( cylinder, *intersection, depth, materials, timer ); // Normal is computed twice!!!\n"
"      normalizeVector(normal);\n"
"      normalizeVector(ray );\n"
"      *shadowIntensity = 5.f*fabs(dotProduct(-ray ,normal));\n"
"      *shadowIntensity = (*shadowIntensity>1.f) ? 1.f : *shadowIntensity;\n"
"   } \n"
"   return result;\n"
"}\n"
"\n"
"bool planeIntersection( \n"
"   Primitive          primitive, \n"
"   float4             origin, \n"
"   float4             ray, \n"
"   bool               reverse,\n"
"   float*             shadowIntensity,\n"
"   __global char*     depth,\n"
"   __global Material* materials,\n"
"   __global char*     textures,\n"
"   float4*            intersection)\n"
"{ \n"
"   float reverted = reverse ? -1.f : 1.f;\n"
"   bool collision = false;\n"
"   switch( primitive.type ) \n"
"   {\n"
"      case ptTopWall:\n"
"      case ptCheckboard:\n"
"         {\n"
"            if( reverted*ray.y<0.f && reverted*origin.y>reverted*primitive.center.y) {\n"
"               (*intersection).y = primitive.center.y;\n"
"               float y = origin.y-primitive.center.y;\n"
"               (*intersection).x = origin.x+y*ray.x/-ray.y;\n"
"               (*intersection).z = origin.z+y*ray.z/-ray.y;\n"
"               collision = fabs((*intersection).x - primitive.center.x) < primitive.size.x &&\n"
"                  fabs((*intersection).z - primitive.center.z) < primitive.size.y;\n"
"         \n"
"            break;\n"
"         }\n"
"      case ptBottomWall:\n"
"         {\n"
"            if( reverted*ray.y>0.f && reverted*origin.y<reverted*primitive.center.y) {\n"
"               (*intersection).y = primitive.center.y;\n"
"               float y = origin.y-primitive.center.y;\n"
"               (*intersection).x = origin.x+y*ray.x/-ray.y;\n"
"               (*intersection).z = origin.z+y*ray.z/-ray.y;\n"
"               collision = fabs((*intersection).x - primitive.center.x) < primitive.size.x &&\n"
"                  fabs((*intersection).z - primitive.center.z) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptCamera:\n"
"         {\n"
"            if( reverted*ray.z>0.f && reverted*origin.z<reverted*primitive.center.z )\n"
"            {\n"
"               (*intersection).z = primitive.center.z;\n"
"               float z = origin.z-primitive.center.z;\n"
"               (*intersection).x = origin.x+z*ray.x/-ray.z;\n"
"               (*intersection).y = origin.y+z*ray.y/-ray.z;\n"
"               collision = fabs((*intersection).x - primitive.center.x) < primitive.size.x &&\n"
"                  fabs((*intersection).y - primitive.center.y) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptLeftWall:\n"
"         {\n"
"            if( reverted*ray.x<0.f && reverted*origin.x>reverted*primitive.center.x ) \n"
"            {\n"
"               (*intersection).x = primitive.center.x;\n"
"               float x = origin.x-primitive.center.x;\n"
"               (*intersection).y = origin.y+x*ray.y/-ray.x;\n"
"               (*intersection).z = origin.z+x*ray.z/-ray.x;\n"
"               collision = fabs((*intersection).y - primitive.center.y) < primitive.size.x &&\n"
"                  fabs((*intersection).z - primitive.center.z) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptRightWall:\n"
"         {\n"
"            if( reverted*ray.x>0.f && reverted*origin.x<reverted*primitive.center.x ) \n"
"            {\n"
"               (*intersection).x = primitive.center.x;\n"
"               float x = origin.x-primitive.center.x;\n"
"               (*intersection).y = origin.y+x*ray.y/-ray.x;\n"
"               (*intersection).z = origin.z+x*ray.z/-ray.x;\n"
"               collision = fabs((*intersection).y - primitive.center.y) < primitive.size.x &&\n"
"                  fabs((*intersection).z - primitive.center.z) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptFrontWall:\n"
"         {\n"
"            if( reverted*ray.z>0.f && reverted*origin.z<reverted*primitive.center.z )\n"
"            {\n"
"               (*intersection).z = primitive.center.z;\n"
"               float z = origin.z-primitive.center.z;\n"
"               (*intersection).x = origin.x+z*ray.x/-ray.z;\n"
"               (*intersection).y = origin.y+z*ray.y/-ray.z;\n"
"               collision = fabs((*intersection).x - primitive.center.x) < primitive.size.x &&\n"
"                  fabs((*intersection).y - primitive.center.y) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptBackWall:\n"
"         {\n"
"            if( reverted*ray.z<0.f && reverted*origin.z>reverted*primitive.center.z) \n"
"            { \n"
"               (*intersection).z = primitive.center.z;\n"
"               float z = origin.z-primitive.center.z;\n"
"               (*intersection).x = origin.x+z*ray.x/-ray.z;\n"
"               (*intersection).y = origin.y+z*ray.y/-ray.z;\n"
"               collision = fabs((*intersection).x - primitive.center.x) < primitive.size.x &&\n"
"                  fabs((*intersection).y - primitive.center.y) < primitive.size.y;\n"
"            }\n"
"            break;\n"
"         }\n"
"      }\n"
"   }\n"
"   *shadowIntensity = 1.f;\n"
"   if( collision && \n"
"      materials[primitive.materialId].color.w != 0.f &&\n"
"      materials[primitive.materialId].transparent==1 && \n"
"      materials[primitive.materialId].textureId!=NO_TEXTURE ) \n"
"   {\n"
"\n"
"      float4 color = cubeMapping(primitive, *intersection, materials, textures );\n"
"      *shadowIntensity = (color.x+color.y+color.z);\n"
"      collision = ( *shadowIntensity <= gTransparentColor );\n"
"      *shadowIntensity = *shadowIntensity/3.f;\n"
"   }\n"
"   //vectorRotation( intersection, primitive.center, -primitive.rotation );\n"
"   return collision;\n"
"}\n"
"\n"
"float shadow( \n"
"   __global Primitive* primitives, \n"
"   int                 nbPrimitives, \n"
"   float4              lampCenter, \n"
"   float4              origin, \n"
"   int                 objectId, \n"
"   float               timer,\n"
"   __global char*      video,\n"
"   __global char*      depth,\n"
"   __global Material*  materials, \n"
"   __global char*      textures )\n"
"{\n"
"   float result = 0.f;\n"
"   float4 O_L = lampCenter - origin;\n"
"   int cptPrimitives = 0;\n"
"   int collision = 0;\n"
"   while( result<1.f && (collision<gNbMaxShadowCollisions) && (cptPrimitives<nbPrimitives) ) \n"
"   {\n"
"      float4 intersection;\n"
"      float shadowIntensity = 0.f;\n"
"      bool hit = false;\n"
"      switch( primitives[cptPrimitives].type ) \n"
"      {\n"
"      case ptSphere: \n"
"         {\n"
"            float4 L_C = primitives[cptPrimitives].center - lampCenter;\n"
"            // sign of dot product tells if they're pointing in the same direction. Must\n"
"            // be positive for vectors to point in the same direction.\n"
"            float d = dotProduct( O_L, L_C );\n"
"            if( d < 0.f || (vectorLength(L_C) < primitives[cptPrimitives].center.w ) ) {\n"
"               hit = sphereIntersection( primitives[cptPrimitives], origin, O_L, timer, &intersection, true, &shadowIntensity, video, depth, materials, textures );\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptCylinder:\n"
"         {\n"
"            float4 L_C = primitives[cptPrimitives].center - lampCenter;\n"
"            // sign of dot product tells if they're pointing in the same direction. Must\n"
"            // be positive for vectors to point in the same direction.\n"
"            float d = dotProduct( O_L, L_C );\n"
"            if( d < 0.f || (vectorLength(L_C) < primitives[cptPrimitives].center.w ) )  // Not correct!\n"
"            {\n"
"               hit = cylinderIntersection( primitives[cptPrimitives], origin, O_L, timer, &intersection, true, &shadowIntensity, video, depth, materials, textures );\n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptCheckboard:\n"
"      case ptLeftWall:\n"
"      case ptRightWall:\n"
"      case ptFrontWall:\n"
"      case ptBackWall:\n"
"      case ptTopWall:\n"
"      case ptBottomWall:\n"
"         {\n"
"            hit = planeIntersection( primitives[cptPrimitives], origin, O_L, true, &shadowIntensity, depth, materials, textures, &intersection );\n"
"            if( hit ) \n"
"            {\n"
"               float4 O_I = intersection - lampCenter;\n"
"               hit = (dotProduct( O_L, O_I ) < 0.f);\n"
"            }\n"
"            break;\n"
"         }\n"
"      }\n"
"\n"
"      if( hit ) \n"
"      {\n"
"         collision++;\n"
"         switch( primitives[cptPrimitives].type ) \n"
"         {\n"
"         case ptSphere:\n"
"         case ptCylinder:\n"
"            {\n"
"               float4 O_I = intersection - origin;\n"
"               // Shadow exists only if object is between origin and lamp\n"
"               if(vectorLength(O_I) < vectorLength(O_L) ) \n"
"               {\n"
"                  if( collision == gNbMaxShadowCollisions ) \n"
"                  {\n"
"                     // As soon as we get more than gNbMaxShadowCollisions intersections between\n"
"                     // the lights and the origin, we do not do\n"
"                     // soft shadows anymore\n"
"                     result = gNbMaxShadowCollisions;\n"
"                  }\n"
"                  else \n"
"                  {\n"
"                     float4 colorAtIntersection = \n"
"                        sphereMapping( primitives[cptPrimitives], intersection, materials, textures );\n"
"\n"
"                     float r = materials[primitives[cptPrimitives].materialId].refraction;\n"
"                     r = ( r == 0.f ) ? 1.f : r;\n"
"\n"
"                     result += shadowIntensity*r*(3.f-colorAtIntersection.x+colorAtIntersection.y+colorAtIntersection.z)/3.f;\n"
"                  }\n"
"               }\n"
"               break;\n"
"            }\n"
"         default:\n"
"            {\n"
"               if( materials[primitives[cptPrimitives].materialId].refraction != 0.f ) \n"
"               {\n"
"                  result += shadowIntensity*materials[primitives[cptPrimitives].materialId].refraction;\n"
"               }\n"
"               else \n"
"               {\n"
"                  result += shadowIntensity;\n"
"               }\n"
"            }\n"
"         }\n"
"      }\n"
"      cptPrimitives++; \n"
"   }\n"
"\n"
"   // result = result/collision;\n"
"   result = (result>1.f) ? 1.f : result;\n"
"   return result;\n"
"}\n"
"\n"
"float4 colorFromObject(\n"
"   __global Primitive* primitives, \n"
"   int                 nbPrimitives, \n"
"   __global Lamp*      lamps, \n"
"   int                 NbLamps, \n"
"   __global char*      video,\n"
"   __global char*      depth,\n"
"   __global Material*  materials,\n"
"   __global char*      textures,\n"
"   float4              origin,\n"
"   float4              normalToSurface, \n"
"   float4              intersection, \n"
"   int                 objectId, \n"
"   float               timer,\n"
"   float4*             refractionFromColor)\n"
"{\n"
"   float4 color;\n"
"   float4 lampsColor;\n"
"   // Ambiant light\n"
"   lampsColor.x = 0.f;\n"
"   lampsColor.y = 0.f;\n"
"   lampsColor.z = 0.f;\n"
"\n"
"   // Lamp Impact\n"
"   float totalIntensity = 0.f;\n"
"   float totalBlinn = 0.f;\n"
"\n"
"   float4 viewRay = intersection - origin;\n"
"   normalizeVector(viewRay);\n"
"\n"
"   for( int cptLamps=0; cptLamps<NbLamps; cptLamps++ ) \n"
"   {\n"
"      if( lamps[cptLamps].color.w != 0.f ) \n"
"      {\n"
"         float shadowIntensity = shadow( primitives, nbPrimitives, lamps[cptLamps].center, intersection, objectId, timer, video, depth, materials, textures );\n"
"         float4 lightRay = lamps[cptLamps].center - intersection;\n"
"\n"
"         if( shadowIntensity <= 1.f )\n"
"         {\n"
"            // Lighted object, not in the shades\n"
"            normalizeVector(lightRay);\n"
"            float d = vectorLength(lightRay);\n"
"\n"
"            // Lambert\n"
"            float lambert = dotProduct( lightRay, normalToSurface ) / d;\n"
"\n"
"            lambert = lambert*lamps[cptLamps].color.w*(1.f-shadowIntensity);\n"
"            lambert = ( lambert < 0.f ) ? 0.f : lambert;\n"
"\n"
"            lampsColor.x += lamps[cptLamps].color.x*lambert;\n"
"            lampsColor.y += lamps[cptLamps].color.y*lambert;\n"
"            lampsColor.z += lamps[cptLamps].color.z*lambert;\n"
"\n"
"            totalIntensity = totalIntensity + lamps[cptLamps].color.w;\n"
"         }\n"
"         if( shadowIntensity == 0.f ) \n"
"         {\n"
"            // --------------------------------------------------------------------------------\n"
"            // Blinn - Phong\n"
"            // --------------------------------------------------------------------------------\n"
"            float4 blinnDir = lightRay - viewRay;\n"
"            float temp = sqrt(dotProduct(blinnDir,blinnDir));\n"
"            if (temp != 0.f ) {\n"
"               // Specular reflection\n"
"               blinnDir.x = (1.f / temp) * blinnDir.x;\n"
"               blinnDir.y = (1.f / temp) * blinnDir.y;\n"
"               blinnDir.z = (1.f / temp) * blinnDir.z;\n"
"\n"
"               float blinnTerm = dotProduct(blinnDir,normalToSurface);\n"
"               blinnTerm = ( blinnTerm < 0.f) ? 0.f : blinnTerm;\n"
"\n"
"               Material material = materials[primitives[objectId].materialId];\n"
"               blinnTerm = material.specular.x * pow(blinnTerm , material.specular.y) * material.specular.w;\n"
"               totalBlinn += lamps[cptLamps].color.w * blinnTerm;\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"\n"
"   //totalIntensity += 0.2f; // Ambient light\n"
"   \n"
"   lampsColor.x = lampsColor.x * totalIntensity;\n"
"   lampsColor.y = lampsColor.y * totalIntensity;\n"
"   lampsColor.z = lampsColor.z * totalIntensity;\n"
"\n"
"   // Final color\n"
"   float4 intersectionColor = objectColorAtIntersection( primitives[objectId], intersection, video, depth, materials, textures, timer, false );\n"
"   color.x = intersectionColor.x*lampsColor.x;\n"
"   color.y = intersectionColor.y*lampsColor.y;\n"
"   color.z = intersectionColor.z*lampsColor.z;\n"
"\n"
"   (*refractionFromColor) = intersectionColor; // Refraction depending on color;\n"
"\n"
"   // Specular reflection\n"
"   color.w = totalBlinn;\n"
"\n"
"   return color;\n"
"}\n"
"\n"
"bool planIntersection( \n"
"   Primitive          plan, \n"
"   float4             origin, \n"
"   float4             ray, \n"
"   __global Material* materials,\n"
"   __global char*     depth,\n"
"   float              timer, \n"
"   float4*            intersection )\n"
"{\n"
"   bool collision  = false;\n"
"   float4 normal = normalToSurface( plan, plan.center, depth, materials, timer  );\n"
"   float B = dotProduct( normal, ray );\n"
"   if(B < 0.f) {\n"
"      origin.x = origin.x + plan.center.x;\n"
"      origin.y = origin.y + plan.center.y;\n"
"      origin.z = origin.z + plan.center.z;\n"
"      float t = -dotProduct( normal, origin )/B;\n"
"      *intersection = origin + t*ray;\n"
"      collision  = true;\n"
"   } \n"
"   return collision;\n"
"}\n"
"\n"
"bool intersectionWithLamps( \n"
"   __global Lamp*      lamps, \n"
"   int                 nbLamps, \n"
"   float4              origin, \n"
"   float4              target, \n"
"   float4*             lampColor)\n"
"{\n"
"   bool intersections = false;\n"
"\n"
"   for( int cptLamps = 0; cptLamps<nbLamps && !intersections; cptLamps++ ) \n"
"   {\n"
"      float4 O_C = origin - lamps[cptLamps].center; \n"
"      float4 ray = target - origin;\n"
"      float4 intersection;\n"
"      intersections = lampIntersection( lamps[cptLamps], origin, ray, O_C, &intersection );\n"
"      if( intersections ) \n"
"      {\n"
"         float4 I_C = intersection - lamps[cptLamps].center;\n"
"         normalizeVector( O_C );\n"
"         normalizeVector( I_C );\n"
"         float d = dotProduct( O_C, I_C ) * lamps[cptLamps].color.w;\n"
"         d = (d<0.f) ? 0.f : d;\n"
"         (*lampColor).x = lamps[cptLamps].color.x*d;\n"
"         (*lampColor).y = lamps[cptLamps].color.y*d;\n"
"         (*lampColor).z = lamps[cptLamps].color.z*d;\n"
"      }\n"
"   }\n"
"   return intersections;\n"
"}\n"
"\n"
"bool intersectionWithObjects( \n"
"   __global Primitive* primitives, \n"
"   int                 nbPrimitives, \n"
"   float4              origin, \n"
"   float4              target, \n"
"   float               timer, \n"
"   int*                closestPrimitive, \n"
"   float4*             closestIntersection,\n"
"   __global char*      video,\n"
"   __global char*      depth,\n"
"   __global Material*  materials,\n"
"   __global char*      textures)\n"
"{\n"
"   bool intersections = false; \n"
"   float minDistance  = gMaxViewDistance; \n"
"   float4 ray = target - origin; \n"
"   float4 intersection;\n"
"\n"
"   for( int cptObjects = 0; cptObjects<nbPrimitives; cptObjects++ )\n"
"   { \n"
"      bool intersec = false; \n"
"      float shadowIntensity;\n"
"\n"
"      switch( primitives[cptObjects].type ) \n"
"      {\n"
"      case ptSphere: \n"
"         {\n"
"            float4 C_O = primitives[cptObjects].center - origin; \n"
"            if( dotProduct( C_O, ray ) > 0.f ) \n"
"            {\n"
"               // Only consider objects in from of the ray\n"
"               intersec = sphereIntersection( primitives[cptObjects], origin, ray, timer, &intersection, false, &shadowIntensity, video, depth, materials, textures ); \n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptCylinder:\n"
"         {\n"
"            float4 C_O = primitives[cptObjects].center - origin; \n"
"            if( dotProduct( C_O, ray ) > 0.f ) \n"
"            {\n"
"               // Only consider objects in from of the ray\n"
"               intersec = cylinderIntersection( primitives[cptObjects], origin, ray, timer, &intersection, false, &shadowIntensity, video, depth, materials, textures ); \n"
"            }\n"
"            break;\n"
"         }\n"
"      case ptTriangle: \n"
"         {\n"
"            intersec = planIntersection( primitives[cptObjects], origin, ray, materials, depth, timer, &intersection ); \n"
"            break;\n"
"         }\n"
"      case ptCheckboard:\n"
"      case ptLeftWall:\n"
"      case ptRightWall:\n"
"      case ptFrontWall:\n"
"      case ptBackWall:\n"
"      case ptTopWall:\n"
"      case ptBottomWall:\n"
"      case ptCamera: \n"
"         {\n"
"            intersec = planeIntersection( primitives[cptObjects], origin, ray, false, &shadowIntensity, depth, materials, textures, &intersection); \n"
"            break;\n"
"         }\n"
"      }\n"
"\n"
"      if( intersec ) {\n"
"         float4 O_I=origin - intersection;\n"
"         float distance = vectorLength(O_I);\n"
"\n"
"         if(distance>1.f && distance<minDistance) {\n"
"            minDistance = distance;\n"
"            *closestPrimitive = cptObjects;\n"
"            *closestIntersection = intersection;\n"
"            intersections = true;\n"
"         } \n"
"      }\n"
"   }\n"
"   return intersections;\n"
"}\n"
"\n"
"float4 launchRay( \n"
"   __global Primitive* primitives, \n"
"   int                 nbPrimitives, \n"
"   __global Lamp*      lamps, \n"
"   int                 nbLamps, \n"
"   float4              origin, \n"
"   float4              target, \n"
"   float               timer,\n"
"   __global Material*  materials,\n"
"   __global char*      textures,\n"
"   __global char*      video,\n"
"   __global char*      depth,\n"
"   float4*             intersection)\n"
"{\n"
"   float4 intersectionColor;\n"
"   int    closestPrimitive;\n"
"   float4 closestIntersection;\n"
"   bool   carryon           = true;\n"
"   float4 rayOrigin         = origin;\n"
"   float4 rayTarget         = target;\n"
"   float  initialRefraction = 1.0f;\n"
"   int    iteration         = 0;\n"
"   float4 O_R;\n"
"   float4 O_E;\n"
"   float4 recursiveColor[10];\n"
"   float  recursiveRatio[10];\n"
"   bool intersectionWithLamp = true;\n"
"\n"
"   for( int i=0; i<10; i++ ) {\n"
"      recursiveColor[i].x = 0.f;\n"
"      recursiveColor[i].y = 0.f;\n"
"      recursiveColor[i].z = 0.f;\n"
"      recursiveColor[i].w = 0.f;\n"
"      recursiveRatio[i]   = 0.0f;\n"
"   }\n"
"\n"
"   while( iteration<gNbIterations && carryon ) \n"
"   {\n"
"      // Compute intesection with lamps\n"
"      carryon = !intersectionWithLamps(\n"
"         lamps, nbLamps,\n"
"         rayOrigin,  \n"
"         rayTarget,\n"
"         &intersectionColor);\n"
"\n"
"      if( carryon ) \n"
"      {\n"
"         intersectionWithLamp = false;\n"
"         // No intersection with lamps detected. Now compute intersection with Primitives\n"
"         carryon = intersectionWithObjects(\n"
"            primitives, \n"
"            nbPrimitives,\n"
"            rayOrigin, \n"
"            rayTarget, \n"
"            timer, \n"
"            &closestPrimitive, \n"
"            &closestIntersection,\n"
"            video,\n"
"            depth,\n"
"            materials,\n"
"            textures);\n"
"\n"
"         if( carryon ) {\n"
"            float4 refractionFromColor;\n"
"            float4 normal = normalToSurface( primitives[closestPrimitive], closestIntersection, depth, materials, timer );\n"
"            float4 reflectedTarget;\n"
"            normalizeVector(normal);\n"
"\n"
"            // Get object color\n"
"            recursiveColor[iteration] = colorFromObject( \n"
"               primitives, nbPrimitives, \n"
"               lamps, nbLamps, \n"
"               video, depth, materials, textures, \n"
"               origin, normal, closestIntersection, closestPrimitive, \n"
"               timer, &refractionFromColor);\n"
"\n"
"            if( materials[primitives[closestPrimitive].materialId].refraction != 0.f ) \n"
"            {\n"
"               // ----------\n"
"               // Refraction\n"
"               // ----------\n"
"\n"
"               // Replace the normal using the intersection color\n"
"               // r,g,b become x,y,z... What the fuck!!\n"
"               if( materials[primitives[closestPrimitive].materialId].textureId != NO_TEXTURE) \n"
"               {\n"
"                  refractionFromColor -= 0.5f;\n"
"                  normal *= refractionFromColor;\n"
"               }\n"
"\n"
"               O_E = rayOrigin - closestIntersection;\n"
"               float refraction = materials[primitives[closestPrimitive].materialId].refraction;\n"
"               refraction = (refraction == initialRefraction) ? 1.0f : refraction;\n"
"               vectorRefraction(&O_R, O_E, refraction, normal, initialRefraction );\n"
"\n"
"               reflectedTarget = closestIntersection - O_R;\n"
"               initialRefraction = refraction;\n"
"               recursiveRatio[iteration] = 1.f-materials[primitives[closestPrimitive].materialId].color.w;\n"
"            }\n"
"            else \n"
"            {\n"
"               // ----------\n"
"               // Reflection\n"
"               // ----------\n"
"               if( materials[primitives[closestPrimitive].materialId].color.w != 0.f ) \n"
"               {\n"
"                  O_E = rayOrigin - closestIntersection;\n"
"                  vectorReflection( &O_R, O_E, normal );\n"
"                  reflectedTarget = closestIntersection - O_R;\n"
"                  recursiveRatio[iteration] = materials[primitives[closestPrimitive].materialId].color.w;\n"
"               }\n"
"               else \n"
"               {\n"
"                  carryon = false;\n"
"               }\n"
"            }\n"
"\n"
"            iteration++;\n"
"\n"
"            rayOrigin = closestIntersection; \n"
"            rayTarget = reflectedTarget; \n"
"         }\n"
"      }\n"
"   }\n"
"\n"
"   for( int i=iteration; i>=0; --i ) {\n"
"      intersectionColor.x = recursiveColor[i+1].x*recursiveRatio[i]+recursiveColor[i].x*(1.f-recursiveRatio[i]);\n"
"      intersectionColor.y = recursiveColor[i+1].y*recursiveRatio[i]+recursiveColor[i].y*(1.f-recursiveRatio[i]);\n"
"      intersectionColor.z = recursiveColor[i+1].z*recursiveRatio[i]+recursiveColor[i].z*(1.f-recursiveRatio[i]);\n"
"\n"
"      // Specular reflection\n"
"      intersectionColor.x += recursiveColor[i].w;\n"
"      intersectionColor.y += recursiveColor[i].w;\n"
"      intersectionColor.z += recursiveColor[i].w;\n"
"\n"
"      intersectionColor.x = (intersectionColor.x>1.f) ? 1.f : intersectionColor.x;\n"
"      intersectionColor.y = (intersectionColor.y>1.f) ? 1.f : intersectionColor.y;\n"
"      intersectionColor.z = (intersectionColor.z>1.f) ? 1.f : intersectionColor.z;\n"
"\n"
"      if( !intersectionWithLamp ) {\n"
"         recursiveColor[i]=intersectionColor;\n"
"      }\n"
"   }\n"
"   *intersection = closestIntersection;\n"
"\n"
"   return intersectionColor;\n"
"}\n"
"\n"
"__kernel void render_kernel( \n"
"   float4               origin,\n"
"   float4               target,\n"
"   float4               angles,\n"
"   int                  width, \n"
"   int                  height, \n"
"   __global Primitive*  primitives, \n"
"   __global Lamp*       lamps, \n"
"   __global Material*   materials, \n"
"   int                  nbPrimitives,\n"
"   int                  nbLamps,\n"
"   int                  nbMaterials,\n"
"   __global char*       bitmap,\n"
"   __global char*       video,\n"
"   __global char*       depth,\n"
"   __global char*       textures,\n"
"   float                timer,\n"
"   int                  draft,\n"
"   float                transparentColor)\n"
"{\n"
"   // Compute the index\n"
"   int x = get_global_id(0);\n"
"   int y = get_global_id(1);\n"
"   int index = y*width+x;\n"
"\n"
"   int halfWidth = width;\n"
"\n"
"   target.x = target.x + (float)(x - (halfWidth/2));\n"
"   target.y = target.y + (float)(y - (height/2));\n"
"\n"
"   float4 rotationCenter;\n"
"   rotationCenter.x = 0.f;\n"
"   rotationCenter.y = 0.f;\n"
"   rotationCenter.z = 0.f;\n"
"\n"
"   vectorRotation( &origin, rotationCenter, angles );\n"
"   vectorRotation( &target, rotationCenter, angles );\n"
"\n"
"   float4 intersection;\n"
"   float4 color = launchRay( \n"
"      primitives, nbPrimitives, \n"
"      lamps, nbLamps, \n"
"      origin, target, timer, \n"
"      materials, textures,\n"
"      video, depth,\n"
"      &intersection);\n"
"\n"
"   color.w = 1.f; //(gMaxViewDistance/intersection.z);\n"
"   for( int j=0; j<draft; j++ ) \n"
"   {\n"
"      makeOpenGLColor( color, bitmap, index+j ); \n"
"   }\n"
"}\n";
